// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require("rescript/lib/js/caml_option.js");
var Graphql_facade = require("./graphql_facade");

function ofType(l) {
  return l.ofType;
}

var List = {
  ofType: ofType
};

function ofType$1(nn) {
  return nn.ofType;
}

var NonNull = {
  ofType: ofType$1
};

var UnionMembers = {};

function parse(prim) {
  return Graphql_facade.wrapClassType(prim);
}

var Named = {
  parse: parse
};

function fromNamed(named) {
  switch (named.TAG) {
    case "Object" :
        return {
                TAG: "Object",
                _0: named._0
              };
    case "Interface" :
        return {
                TAG: "Interface",
                _0: named._0
              };
    case "Union" :
        return {
                TAG: "Union",
                _0: named._0
              };
    default:
      return ;
  }
}

function name(t) {
  return t._0.name;
}

var ValidForTypeCondition = {
  fromNamed: fromNamed,
  name: name
};

function fromNamed$1(named) {
  switch (named.TAG) {
    case "Object" :
        return {
                TAG: "Object",
                _0: named._0
              };
    case "Interface" :
        return {
                TAG: "Interface",
                _0: named._0
              };
    default:
      return ;
  }
}

function fromValidForTypeCondition(typeCond) {
  switch (typeCond.TAG) {
    case "Object" :
        return {
                TAG: "Object",
                _0: typeCond._0
              };
    case "Interface" :
        return {
                TAG: "Interface",
                _0: typeCond._0
              };
    case "Union" :
        return ;
    
  }
}

var ValidForField = {
  fromNamed: fromNamed$1,
  fromValidForTypeCondition: fromValidForTypeCondition
};

function parse$1(prim) {
  return Graphql_facade.wrapClassType(prim);
}

function parse_nn(prim) {
  return Graphql_facade.wrapClassType(prim);
}

var Input = {
  parse: parse$1,
  parse_nn: parse_nn
};

function parse$2(prim) {
  return Graphql_facade.wrapClassType(prim);
}

function parse_nn$1(prim) {
  return Graphql_facade.wrapClassType(prim);
}

function traverse(base, onScalar, onObject, onInterface, onUnion, onEnum, onListOpt, onNullOpt, onNonNullOpt) {
  var onList = onListOpt !== undefined ? onListOpt : (function (r) {
        return r;
      });
  var onNull = onNullOpt !== undefined ? onNullOpt : (function (r) {
        return r;
      });
  var onNonNull = onNonNullOpt !== undefined ? onNonNullOpt : (function (r) {
        return r;
      });
  var down = function (_t, _mods) {
    while(true) {
      var mods = _mods;
      var t = _t;
      var s = Graphql_facade.wrapClassType(t);
      switch (s.TAG) {
        case "Scalar" :
            return [
                    onScalar(s._0),
                    {
                      hd: "NullMark",
                      tl: mods
                    }
                  ];
        case "Object" :
            return [
                    onObject(s._0),
                    {
                      hd: "NullMark",
                      tl: mods
                    }
                  ];
        case "Interface" :
            return [
                    onInterface(s._0),
                    {
                      hd: "NullMark",
                      tl: mods
                    }
                  ];
        case "Union" :
            return [
                    onUnion(s._0),
                    {
                      hd: "NullMark",
                      tl: mods
                    }
                  ];
        case "Enum" :
            return [
                    onEnum(s._0),
                    {
                      hd: "NullMark",
                      tl: mods
                    }
                  ];
        case "List" :
            _mods = {
              hd: "ListMark",
              tl: {
                hd: "NullMark",
                tl: mods
              }
            };
            _t = s._0.ofType;
            continue ;
        case "NonNull" :
            var s$1 = Graphql_facade.wrapClassType(s._0.ofType);
            switch (s$1.TAG) {
              case "Scalar" :
                  return [
                          onScalar(s$1._0),
                          {
                            hd: "NonNullMark",
                            tl: mods
                          }
                        ];
              case "Object" :
                  return [
                          onObject(s$1._0),
                          {
                            hd: "NonNullMark",
                            tl: mods
                          }
                        ];
              case "Interface" :
                  return [
                          onInterface(s$1._0),
                          {
                            hd: "NonNullMark",
                            tl: mods
                          }
                        ];
              case "Union" :
                  return [
                          onUnion(s$1._0),
                          {
                            hd: "NonNullMark",
                            tl: mods
                          }
                        ];
              case "Enum" :
                  return [
                          onEnum(s$1._0),
                          {
                            hd: "NonNullMark",
                            tl: mods
                          }
                        ];
              case "List" :
                  _mods = {
                    hd: "ListMark",
                    tl: {
                      hd: "NonNullMark",
                      tl: mods
                    }
                  };
                  _t = s$1._0.ofType;
                  continue ;
              
            }
        
      }
    };
  };
  var _param = down(base, /* [] */0);
  while(true) {
    var param = _param;
    var tags = param[1];
    var base$1 = param[0];
    if (!tags) {
      return base$1;
    }
    switch (tags.hd) {
      case "NullMark" :
          _param = [
            onNull(base$1),
            tags.tl
          ];
          continue ;
      case "NonNullMark" :
          _param = [
            onNonNull(base$1),
            tags.tl
          ];
          continue ;
      case "ListMark" :
          _param = [
            onList(base$1),
            tags.tl
          ];
          continue ;
      
    }
  };
}

var Output = {
  parse: parse$2,
  parse_nn: parse_nn$1,
  traverse: traverse
};

function name$1(t) {
  return t.name;
}

function description(t) {
  return Caml_option.null_to_opt(t.description);
}

function type_(t) {
  return t.type;
}

function defaultValue(t) {
  return t.defaultValue;
}

function astNode(t) {
  return Caml_option.null_to_opt(t.astNode);
}

var Argument = {
  name: name$1,
  description: description,
  type_: type_,
  defaultValue: defaultValue,
  astNode: astNode
};

function name$2(t) {
  return t.name;
}

function description$1(t) {
  return Caml_option.null_to_opt(t.description);
}

function type_$1(t) {
  return t.type;
}

function args(t) {
  return t.args;
}

function isDeprecated(t) {
  return t.isDeprecated;
}

function deprecationReason(t) {
  return Caml_option.nullable_to_opt(t.deprecationReason);
}

function astNode$1(t) {
  return Caml_option.nullable_to_opt(t.astNode);
}

var Field = {
  name: name$2,
  description: description$1,
  type_: type_$1,
  args: args,
  isDeprecated: isDeprecated,
  deprecationReason: deprecationReason,
  astNode: astNode$1
};

function name$3(t) {
  return t.name;
}

function description$2(t) {
  return Caml_option.null_to_opt(t.description);
}

function locations(t) {
  return t.locations;
}

function isRepeatable(t) {
  return t.isRepeatable;
}

function args$1(t) {
  return t.args;
}

function astNode$2(t) {
  return Caml_option.null_to_opt(t.astNode);
}

var Directive = {
  name: name$3,
  description: description$2,
  locations: locations,
  isRepeatable: isRepeatable,
  args: args$1,
  astNode: astNode$2
};

function name$4(t) {
  return t.name;
}

function description$3(t) {
  return Caml_option.null_to_opt(t.description);
}

function astNode$3(t) {
  return Caml_option.null_to_opt(t.astNode);
}

function extensionASTNodes(t) {
  return Caml_option.null_to_opt(t.extensionASTNodes);
}

var Scalar = {
  name: name$4,
  description: description$3,
  astNode: astNode$3,
  extensionASTNodes: extensionASTNodes
};

function name$5(t) {
  return t.name;
}

function description$4(t) {
  return Caml_option.null_to_opt(t.description);
}

function astNode$4(t) {
  return Caml_option.null_to_opt(t.astNode);
}

function extensionASTNodes$1(t) {
  return Caml_option.null_to_opt(t.extensionASTNodes);
}

function name$6(t) {
  return t.name;
}

function description$5(t) {
  return Caml_option.null_to_opt(t.description);
}

function astNode$5(t) {
  return Caml_option.null_to_opt(t.astNode);
}

function extensionASTNodes$2(t) {
  return Caml_option.null_to_opt(t.extensionASTNodes);
}

function name$7(t) {
  return t.name;
}

function description$6(t) {
  return Caml_option.null_to_opt(t.description);
}

function astNode$6(t) {
  return Caml_option.null_to_opt(t.astNode);
}

function extensionASTNodes$3(t) {
  return Caml_option.null_to_opt(t.extensionASTNodes);
}

function name$8(t) {
  return t.name;
}

function description$7(t) {
  return Caml_option.null_to_opt(t.description);
}

function value(t) {
  return t.value;
}

function isDeprecated$1(t) {
  return t.isDeprecated;
}

function deprecationReason$1(t) {
  return Caml_option.null_to_opt(t.deprecationReason);
}

function astNode$7(t) {
  return Caml_option.nullable_to_opt(t.astNode);
}

var EnumValue = {
  name: name$8,
  description: description$7,
  value: value,
  isDeprecated: isDeprecated$1,
  deprecationReason: deprecationReason$1,
  astNode: astNode$7
};

function name$9(t) {
  return t.name;
}

function description$8(t) {
  return Caml_option.null_to_opt(t.description);
}

function astNode$8(t) {
  return Caml_option.null_to_opt(t.astNode);
}

function extensionASTNodes$4(t) {
  return Caml_option.null_to_opt(t.extensionASTNodes);
}

function getValue(t, s) {
  return Caml_option.null_to_opt(t.getValue(s));
}

function name$10(t) {
  return t.name;
}

function description$9(t) {
  return Caml_option.nullable_to_opt(t.description);
}

function type_$2(t) {
  return t.type;
}

function defaultValue$1(t) {
  return t.defaultValue;
}

function astNode$9(t) {
  return Caml_option.nullable_to_opt(t.astNode);
}

var InputField = {
  name: name$10,
  description: description$9,
  type_: type_$2,
  defaultValue: defaultValue$1,
  astNode: astNode$9
};

function name$11(t) {
  return t.name;
}

function description$10(t) {
  return Caml_option.null_to_opt(t.description);
}

function astNode$10(t) {
  return Caml_option.null_to_opt(t.astNode);
}

function extensionASTNodes$5(t) {
  return Caml_option.null_to_opt(t.extensionASTNodes);
}

function astNode$11(t) {
  return Caml_option.null_to_opt(t.astNode);
}

function extensionASTNodes$6(t) {
  return Caml_option.null_to_opt(t.extensionASTNodes);
}

var Abstract = {};

function Object_getFields(prim) {
  return prim.getFields();
}

function Object_getInterfaces(prim) {
  return prim.getInterfaces();
}

var $$Object = {
  name: name$5,
  description: description$4,
  astNode: astNode$4,
  extensionASTNodes: extensionASTNodes$1,
  getFields: Object_getFields,
  getInterfaces: Object_getInterfaces
};

function Interface_getFields(prim) {
  return prim.getFields();
}

function Interface_toAbstract(prim) {
  return prim;
}

var Interface = {
  name: name$6,
  description: description$5,
  astNode: astNode$5,
  extensionASTNodes: extensionASTNodes$2,
  getFields: Interface_getFields,
  toAbstract: Interface_toAbstract
};

function Union_getTypes(prim) {
  return prim.getTypes();
}

function Union_toAbstract(prim) {
  return prim;
}

var Union = {
  name: name$7,
  description: description$6,
  astNode: astNode$6,
  extensionASTNodes: extensionASTNodes$3,
  getTypes: Union_getTypes,
  toAbstract: Union_toAbstract
};

function Enum_getValues(prim) {
  return prim.getValues();
}

var Enum = {
  name: name$9,
  description: description$8,
  astNode: astNode$8,
  extensionASTNodes: extensionASTNodes$4,
  getValues: Enum_getValues,
  getValue: getValue
};

function InputObject_getFields(prim) {
  return prim.getFields();
}

var InputObject = {
  name: name$11,
  description: description$10,
  astNode: astNode$10,
  extensionASTNodes: extensionASTNodes$5,
  getFields: InputObject_getFields
};

function getQueryType(prim) {
  return Caml_option.nullable_to_opt(prim.getQueryType());
}

function getMutationType(prim) {
  return Caml_option.nullable_to_opt(prim.getMutationType());
}

function getSubscriptionType(prim) {
  return Caml_option.nullable_to_opt(prim.getSubscriptionType());
}

function getTypeMap(prim) {
  return prim.getTypeMap();
}

function getType(prim0, prim1) {
  return Caml_option.nullable_to_opt(prim0.getType(prim1));
}

function getPossibleTypes(prim0, prim1) {
  return prim0.getPossibleTypes(prim1);
}

function isPossibleType(prim0, prim1, prim2) {
  return prim0.isPossibleType(prim1, prim2);
}

function getDirectives(prim) {
  return prim.getDirectives();
}

function getDirective(prim0, prim1) {
  return Caml_option.nullable_to_opt(prim0.getDirectives(prim1));
}

exports.UnionMembers = UnionMembers;
exports.Named = Named;
exports.ValidForTypeCondition = ValidForTypeCondition;
exports.ValidForField = ValidForField;
exports.Abstract = Abstract;
exports.Input = Input;
exports.Output = Output;
exports.Argument = Argument;
exports.Field = Field;
exports.Directive = Directive;
exports.Scalar = Scalar;
exports.$$Object = $$Object;
exports.Interface = Interface;
exports.Union = Union;
exports.EnumValue = EnumValue;
exports.Enum = Enum;
exports.InputField = InputField;
exports.InputObject = InputObject;
exports.List = List;
exports.NonNull = NonNull;
exports.astNode = astNode$11;
exports.extensionASTNodes = extensionASTNodes$6;
exports.getQueryType = getQueryType;
exports.getMutationType = getMutationType;
exports.getSubscriptionType = getSubscriptionType;
exports.getTypeMap = getTypeMap;
exports.getType = getType;
exports.getPossibleTypes = getPossibleTypes;
exports.isPossibleType = isPossibleType;
exports.getDirectives = getDirectives;
exports.getDirective = getDirective;
/* ./graphql_facade Not a pure module */
