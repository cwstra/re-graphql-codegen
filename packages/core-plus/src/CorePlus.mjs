// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "../../../node_modules/rescript/lib/es6/caml_obj.js";
import * as Core__Dict from "../../../node_modules/@rescript/core/src/Core__Dict.mjs";
import * as Caml_option from "../../../node_modules/rescript/lib/es6/caml_option.js";
import * as Core__Array from "../../../node_modules/@rescript/core/src/Core__Array.mjs";
import * as Core__Error from "../../../node_modules/@rescript/core/src/Core__Error.mjs";
import * as Core__Option from "../../../node_modules/@rescript/core/src/Core__Option.mjs";
import * as Core__Result from "../../../node_modules/@rescript/core/src/Core__Result.mjs";
import * as Core__String from "../../../node_modules/@rescript/core/src/Core__String.mjs";
import * as Core__Ordering from "../../../node_modules/@rescript/core/src/Core__Ordering.mjs";
import * as Camelcase_facadeMjs from "./camelcase_facade.mjs";

function $$setTimeout$1(prim0, prim1) {
  return setTimeout(prim0, prim1);
}

function setTimeoutFloat(prim0, prim1) {
  return setTimeout(prim0, prim1);
}

function $$clearTimeout$1(prim) {
  clearTimeout(prim);
}

function $$setInterval$1(prim0, prim1) {
  return setInterval(prim0, prim1);
}

function setIntervalFloat(prim0, prim1) {
  return setInterval(prim0, prim1);
}

function $$clearInterval$1(prim) {
  clearInterval(prim);
}

function $$encodeURI$1(prim) {
  return encodeURI(prim);
}

function $$decodeURI$1(prim) {
  return decodeURI(prim);
}

function $$encodeURIComponent$1(prim) {
  return encodeURIComponent(prim);
}

function $$decodeURIComponent$1(prim) {
  return decodeURIComponent(prim);
}

function takeDropWhile(arr, fn) {
  var ind = arr.findIndex(function (e) {
        return !fn(e);
      });
  if (ind === -1) {
    return [
            arr,
            []
          ];
  } else {
    return [
            arr.slice(0, ind),
            arr.slice(ind)
          ];
  }
}

var groupBy = ((arr, fn) => {
      const result = {}
      arr.forEach(e => {
        const key = fn(e)
        if (key in result) {
          result[key][1].push(e)
        } else {
          result[key] = [e, []]
        }
      })
      return result;
    });

var uniqBy = ((arr, fn) => {
      const m = new Map()
      arr.forEach(e => {
        const key = fn(e)
        if (!m.has(key)) {
          m.set(key, e)
        }
      });
      return new Array(...m.values())
    });

function headTail(arr) {
  var e = arr.at(0);
  if (e !== undefined) {
    return [
            Caml_option.valFromOption(e),
            arr.slice(1)
          ];
  }
  
}

var $$Array = {
  make: Core__Array.make,
  fromInitializer: Core__Array.fromInitializer,
  equal: Core__Array.equal,
  compare: Core__Array.compare,
  indexOfOpt: Core__Array.indexOfOpt,
  lastIndexOfOpt: Core__Array.lastIndexOfOpt,
  reduce: Core__Array.reduce,
  reduceWithIndex: Core__Array.reduceWithIndex,
  reduceRight: Core__Array.reduceRight,
  reduceRightWithIndex: Core__Array.reduceRightWithIndex,
  findIndexOpt: Core__Array.findIndexOpt,
  filterMap: Core__Array.filterMap,
  keepSome: Core__Array.keepSome,
  toShuffled: Core__Array.toShuffled,
  shuffle: Core__Array.shuffle,
  findMap: Core__Array.findMap,
  last: Core__Array.last,
  takeDropWhile: takeDropWhile,
  groupBy: groupBy,
  uniqBy: uniqBy,
  headTail: headTail
};

var put = ((dict, key, value) => ({...dict, [key]: value}));

var merge = ((d1, d2) => ({...d1, ...d2}));

var mergeWith = ((d1, d2, fn) => {
      const result = {...d1}
      Object.entries(d2).forEach(([k, v]) => {
        result[k] =
          k in d1
            ? fn(d1[k], d2[k])
            : d2[k]
      })
      return result
    });

var update = ((dict, key, fn) => ({...dict, [key]: fn(dict[key])}));

var Dict = {
  $$delete: Core__Dict.$$delete,
  forEach: Core__Dict.forEach,
  forEachWithKey: Core__Dict.forEachWithKey,
  mapValues: Core__Dict.mapValues,
  put: put,
  merge: merge,
  mergeWith: mergeWith,
  update: update
};

function ok_or(opt, err) {
  if (opt !== undefined) {
    return {
            TAG: "Ok",
            _0: Caml_option.valFromOption(opt)
          };
  } else {
    return {
            TAG: "Error",
            _0: err
          };
  }
}

var apply = ((mFn, a) => mFn?.(a));

var apply2 = ((mFn, a, b) => mFn?.(a, b));

function toArray(opt) {
  if (opt !== undefined) {
    return [Caml_option.valFromOption(opt)];
  } else {
    return [];
  }
}

function traverse(arr, fn) {
  return Core__Array.reduce(arr, [], (function (res, ele) {
                return Core__Option.flatMap(res, (function (arr) {
                              return Core__Option.map(fn(ele), (function (a) {
                                            arr.push(a);
                                            return arr;
                                          }));
                            }));
              }));
}

function liftConcat(concat, o1, o2) {
  if (o1 !== undefined) {
    if (o2 !== undefined) {
      return Caml_option.some(concat(Caml_option.valFromOption(o1), Caml_option.valFromOption(o2)));
    } else {
      return o1;
    }
  } else {
    return o2;
  }
}

function getOrExn(o, e) {
  if (o !== undefined) {
    return Caml_option.valFromOption(o);
  }
  throw e;
}

function getOrPanic(o, msg) {
  if (o !== undefined) {
    return Caml_option.valFromOption(o);
  } else {
    return Core__Error.panic(msg);
  }
}

var $$Option = {
  filter: Core__Option.filter,
  forEach: Core__Option.forEach,
  getExn: Core__Option.getExn,
  mapOr: Core__Option.mapOr,
  mapWithDefault: Core__Option.mapWithDefault,
  map: Core__Option.map,
  flatMap: Core__Option.flatMap,
  getOr: Core__Option.getOr,
  getWithDefault: Core__Option.getWithDefault,
  orElse: Core__Option.orElse,
  isSome: Core__Option.isSome,
  isNone: Core__Option.isNone,
  equal: Core__Option.equal,
  compare: Core__Option.compare,
  ok_or: ok_or,
  apply: apply,
  apply2: apply2,
  toArray: toArray,
  traverse: traverse,
  liftConcat: liftConcat,
  getOrExn: getOrExn,
  getOrPanic: getOrPanic
};

function traverse$1(arr, fn) {
  return Core__Array.reduce(arr, {
              TAG: "Ok",
              _0: []
            }, (function (res, ele) {
                return Core__Result.flatMap(res, (function (arr) {
                              return Core__Result.map(fn(ele), (function (a) {
                                            arr.push(a);
                                            return arr;
                                          }));
                            }));
              }));
}

var Result = {
  getExn: Core__Result.getExn,
  mapOr: Core__Result.mapOr,
  mapWithDefault: Core__Result.mapWithDefault,
  map: Core__Result.map,
  flatMap: Core__Result.flatMap,
  getOr: Core__Result.getOr,
  getWithDefault: Core__Result.getWithDefault,
  isOk: Core__Result.isOk,
  isError: Core__Result.isError,
  equal: Core__Result.equal,
  compare: Core__Result.compare,
  forEach: Core__Result.forEach,
  mapError: Core__Result.mapError,
  traverse: traverse$1
};

function partition(arr) {
  var lefts = [];
  var rights = [];
  arr.forEach(function (elem) {
        if (elem.TAG === "Left") {
          lefts.push(elem._0);
          return ;
        }
        rights.push(elem._0);
      });
  return [
          lefts,
          rights
        ];
}

function partitionMap(arr, fn) {
  var lefts = [];
  var rights = [];
  arr.forEach(function (elem) {
        var l = fn(elem);
        if (l.TAG === "Left") {
          lefts.push(l._0);
          return ;
        }
        rights.push(l._0);
      });
  return [
          lefts,
          rights
        ];
}

var Either = {
  partition: partition,
  partitionMap: partitionMap
};

function compare(a, b) {
  if (Caml_obj.equal(a, b)) {
    return 0;
  } else if (Caml_obj.lessthan(a, b)) {
    return -1;
  } else {
    return 1;
  }
}

var Ordering = {
  isLess: Core__Ordering.isLess,
  isEqual: Core__Ordering.isEqual,
  isGreater: Core__Ordering.isGreater,
  invert: Core__Ordering.invert,
  fromInt: Core__Ordering.fromInt,
  compare: compare
};

function capitalize(s) {
  return s.charAt(0).toUpperCase().concat(s.slice(1));
}

function pascalCase(prim) {
  return Camelcase_facadeMjs.pascalCase(prim);
}

var $$String = {
  equal: Core__String.equal,
  compare: Core__String.compare,
  indexOfOpt: Core__String.indexOfOpt,
  lastIndexOfOpt: Core__String.lastIndexOfOpt,
  searchOpt: Core__String.searchOpt,
  capitalize: capitalize,
  pascalCase: pascalCase
};

var Console;

var $$DataView;

var $$Date;

var $$Error;

var Float;

var Int;

var $$BigInt;

var $$Math;

var Null;

var Nullable;

var $$Object;

var $$Promise;

var $$RegExp;

var $$Symbol;

var Type;

var $$JSON;

var Iterator;

var AsyncIterator;

var $$Map;

var $$WeakMap;

var $$Set;

var $$WeakSet;

var $$ArrayBuffer;

var TypedArray;

var $$Float32Array;

var $$Float64Array;

var $$Int8Array;

var $$Int16Array;

var $$Int32Array;

var $$Uint8Array;

var $$Uint16Array;

var $$Uint32Array;

var $$Uint8ClampedArray;

var $$BigInt64Array;

var $$BigUint64Array;

var $$Intl;

var MapperRt;

var Internal;

var Re;

var Exn;

var List;

var panic = Core__Error.panic;

export {
  $$setTimeout$1 as $$setTimeout,
  setTimeoutFloat ,
  $$clearTimeout$1 as $$clearTimeout,
  $$setInterval$1 as $$setInterval,
  setIntervalFloat ,
  $$clearInterval$1 as $$clearInterval,
  $$encodeURI$1 as $$encodeURI,
  $$decodeURI$1 as $$decodeURI,
  $$encodeURIComponent$1 as $$encodeURIComponent,
  $$decodeURIComponent$1 as $$decodeURIComponent,
  $$Array ,
  Console ,
  $$DataView ,
  $$Date ,
  $$Error ,
  Float ,
  Int ,
  $$BigInt ,
  $$Math ,
  Null ,
  Nullable ,
  $$Object ,
  $$Promise ,
  $$RegExp ,
  $$Symbol ,
  Type ,
  $$JSON ,
  Iterator ,
  AsyncIterator ,
  $$Map ,
  $$WeakMap ,
  $$Set ,
  $$WeakSet ,
  $$ArrayBuffer ,
  TypedArray ,
  $$Float32Array ,
  $$Float64Array ,
  $$Int8Array ,
  $$Int16Array ,
  $$Int32Array ,
  $$Uint8Array ,
  $$Uint16Array ,
  $$Uint32Array ,
  $$Uint8ClampedArray ,
  $$BigInt64Array ,
  $$BigUint64Array ,
  $$Intl ,
  MapperRt ,
  Internal ,
  Re ,
  Exn ,
  List ,
  panic ,
  Dict ,
  $$Option ,
  Result ,
  Either ,
  Ordering ,
  $$String ,
}
/* ./camelcase_facade.mjs Not a pure module */
