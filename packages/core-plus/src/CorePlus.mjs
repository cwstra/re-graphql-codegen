// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Core__Dict = require("@rescript/core/src/Core__Dict.mjs");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/src/Core__Array.mjs");
var Core__Error = require("@rescript/core/src/Core__Error.mjs");
var Core__Option = require("@rescript/core/src/Core__Option.mjs");
var Core__Result = require("@rescript/core/src/Core__Result.mjs");
var Core__String = require("@rescript/core/src/Core__String.mjs");
var Core__Ordering = require("@rescript/core/src/Core__Ordering.mjs");

function $$setTimeout$1(prim0, prim1) {
  return setTimeout(prim0, prim1);
}

function setTimeoutFloat(prim0, prim1) {
  return setTimeout(prim0, prim1);
}

function $$clearTimeout$1(prim) {
  clearTimeout(prim);
}

function $$setInterval$1(prim0, prim1) {
  return setInterval(prim0, prim1);
}

function setIntervalFloat(prim0, prim1) {
  return setInterval(prim0, prim1);
}

function $$clearInterval$1(prim) {
  clearInterval(prim);
}

function $$encodeURI$1(prim) {
  return encodeURI(prim);
}

function $$decodeURI$1(prim) {
  return decodeURI(prim);
}

function $$encodeURIComponent$1(prim) {
  return encodeURIComponent(prim);
}

function $$decodeURIComponent$1(prim) {
  return decodeURIComponent(prim);
}

function takeDropWhile(arr, fn) {
  var ind = arr.findIndex(function (e) {
        return !fn(e);
      });
  if (ind === -1) {
    return [
            arr,
            []
          ];
  } else {
    return [
            arr.slice(0, ind),
            arr.slice(ind)
          ];
  }
}

var groupBy = ((arr, fn) => {
      const result = {}
      arr.forEach(e => {
        const key = fn(e)
        if (key in result) {
          result[key][1].push(e)
        } else {
          result[key] = [e, []]
        }
      })
      return result;
    });

var uniqBy = ((arr, fn) => {
      const m = new Map()
      arr.forEach(e => {
        const key = fn(e)
        if (!m.has(key)) {
          m.set(key, e)
        }
      });
      return new Array(...m.values())
    });

function headTail(arr) {
  var match = arr.at(0);
  var match$1 = arr.slice(1);
  if (match !== undefined) {
    return [
            Caml_option.valFromOption(match),
            match$1
          ];
  }
  
}

var $$Array = {
  make: Core__Array.make,
  fromInitializer: Core__Array.fromInitializer,
  equal: Core__Array.equal,
  compare: Core__Array.compare,
  indexOfOpt: Core__Array.indexOfOpt,
  lastIndexOfOpt: Core__Array.lastIndexOfOpt,
  reduce: Core__Array.reduce,
  reduceWithIndex: Core__Array.reduceWithIndex,
  reduceRight: Core__Array.reduceRight,
  reduceRightWithIndex: Core__Array.reduceRightWithIndex,
  findIndexOpt: Core__Array.findIndexOpt,
  filterMap: Core__Array.filterMap,
  keepSome: Core__Array.keepSome,
  toShuffled: Core__Array.toShuffled,
  shuffle: Core__Array.shuffle,
  findMap: Core__Array.findMap,
  takeDropWhile: takeDropWhile,
  groupBy: groupBy,
  uniqBy: uniqBy,
  headTail: headTail
};

var put = ((dict, key, value) => ({...dict, [key]: value}));

var merge = ((d1, d2) => ({...d1, ...d2}));

var mergeWith = ((d1, d2, fn) => {
      const result = {...d1}
      Object.entries(d2).forEach(([k, v]) => {
        result[k] = 
          k in d1 
            ? fn(d1[k], d2[k])
            : d2[k]
      })
      return result
    });

var update = ((dict, key, fn) => ({...dict, [key]: fn(dict[key])}));

var Dict = {
  $$delete: Core__Dict.$$delete,
  put: put,
  merge: merge,
  mergeWith: mergeWith,
  update: update
};

function ok_or(opt, err) {
  if (opt !== undefined) {
    return {
            TAG: "Ok",
            _0: Caml_option.valFromOption(opt)
          };
  } else {
    return {
            TAG: "Error",
            _0: err
          };
  }
}

var apply = ((mFn, a) => mFn?.(a));

var apply2 = ((mFn, a, b) => mFn?.(a, b));

function toArray(opt) {
  if (opt !== undefined) {
    return [Caml_option.valFromOption(opt)];
  } else {
    return [];
  }
}

function traverse(arr, fn) {
  return Core__Array.reduce(arr, [], (function (res, ele) {
                return Core__Option.flatMap(res, (function (arr) {
                              return Core__Option.map(fn(ele), (function (a) {
                                            arr.push(a);
                                            return arr;
                                          }));
                            }));
              }));
}

function liftConcat(concat, o1, o2) {
  if (o1 !== undefined) {
    if (o2 !== undefined) {
      return Caml_option.some(concat(Caml_option.valFromOption(o1), Caml_option.valFromOption(o2)));
    } else {
      return o1;
    }
  } else {
    return o2;
  }
}

function getOrExn(o, e) {
  if (o !== undefined) {
    return Caml_option.valFromOption(o);
  }
  throw e;
}

var $$Option = {
  filter: Core__Option.filter,
  forEach: Core__Option.forEach,
  getExn: Core__Option.getExn,
  mapOr: Core__Option.mapOr,
  mapWithDefault: Core__Option.mapWithDefault,
  map: Core__Option.map,
  flatMap: Core__Option.flatMap,
  getOr: Core__Option.getOr,
  getWithDefault: Core__Option.getWithDefault,
  orElse: Core__Option.orElse,
  isSome: Core__Option.isSome,
  isNone: Core__Option.isNone,
  equal: Core__Option.equal,
  compare: Core__Option.compare,
  ok_or: ok_or,
  apply: apply,
  apply2: apply2,
  toArray: toArray,
  traverse: traverse,
  liftConcat: liftConcat,
  getOrExn: getOrExn
};

function traverse$1(arr, fn) {
  return Core__Array.reduce(arr, {
              TAG: "Ok",
              _0: []
            }, (function (res, ele) {
                return Core__Result.flatMap(res, (function (arr) {
                              return Core__Result.map(fn(ele), (function (a) {
                                            arr.push(a);
                                            return arr;
                                          }));
                            }));
              }));
}

var Result = {
  getExn: Core__Result.getExn,
  mapOr: Core__Result.mapOr,
  mapWithDefault: Core__Result.mapWithDefault,
  map: Core__Result.map,
  flatMap: Core__Result.flatMap,
  getOr: Core__Result.getOr,
  getWithDefault: Core__Result.getWithDefault,
  isOk: Core__Result.isOk,
  isError: Core__Result.isError,
  equal: Core__Result.equal,
  compare: Core__Result.compare,
  forEach: Core__Result.forEach,
  mapError: Core__Result.mapError,
  traverse: traverse$1
};

function partition(arr, fn) {
  var lefts = [];
  var rights = [];
  arr.forEach(function (elem) {
        var l = fn(elem);
        if (l.TAG === "Left") {
          lefts.push(l._0);
          return ;
        }
        rights.push(l._0);
      });
  return [
          lefts,
          rights
        ];
}

var Either = {
  partition: partition
};

function compare(a, b) {
  if (Caml_obj.equal(a, b)) {
    return 0;
  } else if (Caml_obj.lessthan(a, b)) {
    return -1;
  } else {
    return 1;
  }
}

var Ordering = {
  isLess: Core__Ordering.isLess,
  isEqual: Core__Ordering.isEqual,
  isGreater: Core__Ordering.isGreater,
  invert: Core__Ordering.invert,
  fromInt: Core__Ordering.fromInt,
  compare: compare
};

function capitalize(s) {
  return s.charAt(0).toUpperCase().concat(s.slice(1));
}

var $$String = {
  equal: Core__String.equal,
  compare: Core__String.compare,
  indexOfOpt: Core__String.indexOfOpt,
  lastIndexOfOpt: Core__String.lastIndexOfOpt,
  searchOpt: Core__String.searchOpt,
  capitalize: capitalize
};

var Console;

var $$DataView;

var $$Date;

var $$Error;

var Float;

var Int;

var $$BigInt;

var $$Math;

var Null;

var Nullable;

var $$Object;

var $$Promise;

var $$RegExp;

var $$Symbol;

var Type;

var $$JSON;

var Iterator;

var AsyncIterator;

var $$Map;

var $$WeakMap;

var $$Set;

var $$WeakSet;

var $$ArrayBuffer;

var TypedArray;

var $$Float32Array;

var $$Float64Array;

var $$Int8Array;

var $$Int16Array;

var $$Int32Array;

var $$Uint8Array;

var $$Uint16Array;

var $$Uint32Array;

var $$Uint8ClampedArray;

var $$BigInt64Array;

var $$BigUint64Array;

var $$Intl;

var MapperRt;

var Internal;

var Re;

var Exn;

var List;

var panic = Core__Error.panic;

exports.$$setTimeout = $$setTimeout$1;
exports.setTimeoutFloat = setTimeoutFloat;
exports.$$clearTimeout = $$clearTimeout$1;
exports.$$setInterval = $$setInterval$1;
exports.setIntervalFloat = setIntervalFloat;
exports.$$clearInterval = $$clearInterval$1;
exports.$$encodeURI = $$encodeURI$1;
exports.$$decodeURI = $$decodeURI$1;
exports.$$encodeURIComponent = $$encodeURIComponent$1;
exports.$$decodeURIComponent = $$decodeURIComponent$1;
exports.$$Array = $$Array;
exports.Console = Console;
exports.$$DataView = $$DataView;
exports.$$Date = $$Date;
exports.$$Error = $$Error;
exports.Float = Float;
exports.Int = Int;
exports.$$BigInt = $$BigInt;
exports.$$Math = $$Math;
exports.Null = Null;
exports.Nullable = Nullable;
exports.$$Object = $$Object;
exports.$$Promise = $$Promise;
exports.$$RegExp = $$RegExp;
exports.$$Symbol = $$Symbol;
exports.Type = Type;
exports.$$JSON = $$JSON;
exports.Iterator = Iterator;
exports.AsyncIterator = AsyncIterator;
exports.$$Map = $$Map;
exports.$$WeakMap = $$WeakMap;
exports.$$Set = $$Set;
exports.$$WeakSet = $$WeakSet;
exports.$$ArrayBuffer = $$ArrayBuffer;
exports.TypedArray = TypedArray;
exports.$$Float32Array = $$Float32Array;
exports.$$Float64Array = $$Float64Array;
exports.$$Int8Array = $$Int8Array;
exports.$$Int16Array = $$Int16Array;
exports.$$Int32Array = $$Int32Array;
exports.$$Uint8Array = $$Uint8Array;
exports.$$Uint16Array = $$Uint16Array;
exports.$$Uint32Array = $$Uint32Array;
exports.$$Uint8ClampedArray = $$Uint8ClampedArray;
exports.$$BigInt64Array = $$BigInt64Array;
exports.$$BigUint64Array = $$BigUint64Array;
exports.$$Intl = $$Intl;
exports.MapperRt = MapperRt;
exports.Internal = Internal;
exports.Re = Re;
exports.Exn = Exn;
exports.List = List;
exports.panic = panic;
exports.Dict = Dict;
exports.$$Option = $$Option;
exports.Result = Result;
exports.Either = Either;
exports.Ordering = Ordering;
exports.$$String = $$String;
/* No side effect */
