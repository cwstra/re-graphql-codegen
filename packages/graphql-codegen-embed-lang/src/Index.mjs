#!/usr/bin/env node
// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_exn from "../../../node_modules/rescript/lib/es6/js_exn.js";
import * as Nodefs from "node:fs";
import * as Process from "process";
import * as Nodepath from "node:path";
import * as RescriptCore from "../../../node_modules/@rescript/core/src/RescriptCore.mjs";
import * as RescriptEmbedLang from "../../../node_modules/rescript-embed-lang/src/RescriptEmbedLang.mjs";
import * as Caml_js_exceptions from "../../../node_modules/rescript/lib/es6/caml_js_exceptions.js";
import * as Codegen$GraphqlCodegenOperations from "./Codegen.mjs";
import * as OptionPlus$GraphqlCodegenOperations from "./OptionPlus.mjs";

var usage = "Usage:\n  generate                                                | Generates all GraphQL code.\n    [--config <path>]                                     | Filepath to GraphQL config.\n    [--src <path>]                                        | The source folder for where to look for ReScript files.\n    [--output <path>]                                     | Where to emit all generated files.\n    [--watch]                                             | Runs this command in watch mode.\n\n  unused-selections                                       | Check if we there are unused selections in your GraphQL queries.\n    [--ci]                                                | Run in CI mode.\n\n  extract <filePath>                                      | Extract all %graphql tags in file at <filePath>.";

async function isInConfigDir() {
  var cwd = Process.cwd();
  var bsconfig = Nodepath.resolve(cwd, "bsconfig.json");
  var rescriptJson = Nodepath.resolve(cwd, "rescript.json");
  try {
    await Nodefs.promises.access(bsconfig);
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Js_exn.$$Error) {
      try {
        await Nodefs.promises.access(rescriptJson);
        return true;
      }
      catch (raw_exn$1){
        var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
        if (exn$1.RE_EXN_ID === Js_exn.$$Error) {
          return false;
        }
        throw exn$1;
      }
    } else {
      throw exn;
    }
  }
}

async function main() {
  new Map();
  var emitter = RescriptEmbedLang.make({
        TAG: "Generic",
        _0: "graphql"
      }, (async function (param) {
          var args = param.args;
          var configPath = RescriptEmbedLang.CliArgs.getArgValue(args, ["--config"]);
          var outDir = OptionPlus$GraphqlCodegenOperations.getOrPanic(RescriptEmbedLang.CliArgs.getArgValue(args, ["--output"]), "Missing output file");
          var match = await Codegen$GraphqlCodegenOperations.getConfig(configPath);
          return {
                  ppxConfigRef: {
                    contents: match[0]
                  },
                  mainConfigPath: match[1],
                  outDir: outDir
                };
        }), (async function (param) {
          var match = await Codegen$GraphqlCodegenOperations.run(param.config.ppxConfigRef.contents, param.path, param.content);
          var len = match.length;
          if (len !== 1) {
            if (len !== 0) {
              return RescriptCore.panic("Multiple results returned");
            } else {
              return RescriptCore.panic("No results returned");
            }
          }
          var val = match[0];
          return {
                  TAG: "Ok",
                  _0: {
                    kind: "NoModuleName",
                    content: val.content
                  }
                };
        }), usage, undefined, (async function (param) {
          
        }));
  return RescriptEmbedLang.runCli(emitter, undefined);
}

main();

var Path;

export {
  Path ,
  usage ,
  isInConfigDir ,
  main ,
}
/*  Not a pure module */
